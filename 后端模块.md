# RestBean响应类

需要将RestBean转换为json格式，用到fastjson相关api
```xml
 <!--    FastJSON2框架    -->
<dependency>
  <groupId>com.alibaba.fastjson2</groupId>
  <artifactId>fastjson2</artifactId>
  <version>2.0.25</version>
</dependency>
```

com.xiaoRed.entity.RestBean
```java
/**
 * 响应实体类封装，Rest风格
 * @param code 状态码
 * @param data 响应数据
 * @param message 其他消息
 * @param <T> 响应数据类型
 */
public record RestBean<T>(int code, T data, String message) {

    //成功响应，携带数据返回
    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200, data, "请求成功");
    }

    //成功响应，不携带数据返回
    public static <T> RestBean<T> success(){
        return new RestBean<>(200, null, "请求成功");
    }

    //响应失败，需要返回错误码和错误信息
    public static <T> RestBean<T> failure(int code, String message){
        return new RestBean<>(code, null, message);
    }

    //将响应对象转换为Json格式
    public String asJsonString(){
        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);
    }

}
```

# SpringSecurity基本配置
>SpringSecurity6.1.2开始，配置的写法和以前相比有所变化，`.and()`写法被抛弃，现在要写lambda表达式

com.xiaoRed.config.SecurityConfiguration
把基本的登录，登出配置一下，把csrf，session关掉
```java
/**
 * SpringSecurity相关配置
 */
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       return http
               .authorizeHttpRequests(conf ->conf
                       .requestMatchers("/api/auth/**").permitAll()
                       .anyRequest().authenticated())
               .formLogin(conf -> conf
                       .loginProcessingUrl("/api/auth/login")
                       .successHandler(this::onAuthenticationSuccess)
                       .failureHandler(this::onAuthenticationFailure))
               .logout(conf -> conf
                       .logoutUrl("/api/auth/logout")
                       .logoutSuccessHandler(this::onLogoutSuccess))
               .csrf(AbstractHttpConfigurer::disable)
               //采用JWT方案，不用session了
               .sessionManagement(conf -> conf
                       .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
               .build();
    }

    //认证成功处理器
    private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                         Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.success().asJsonString());
    }

    //认证失败处理器
    private void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                         AuthenticationException exception) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.failure(401, exception.getMessage()).asJsonString());
    }

    //退出登录成功处理器
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,
                                Authentication authentication) throws IOException, ServletException {

    }
}
```

# JWT颁发

JWT常量类
com.xiaoRed.constants.JwtConstant
```java
/**
 * JWT常量类
 */
public class JwtConstant {

    //jwt密钥，随便设，建议长一点
    public static final String JWT_SECRET = "asdadevvefe";

    //jwt失效时间，单位秒。这里一共是24小时
    public static final Long JWT_EXPIRATION = 24 * 60 * 60 * 1000L;
}
```

JWT工具类
com.xiaoRed.utils.JwtUtil
```java
/**
 * Jwt工具类
 */
@Component
public class JwtUtil {

    /**
     * 生成JWT令牌
     * @return 令牌
     */
    public String createJWT(UserDetails details, int id, String username){
        Algorithm algorithm = Algorithm.HMAC256(JwtConstant.JWT_SECRET);//设置加密算法
        return JWT.create()
                .withClaim("id", id)
                .withClaim("name", username)
                .withClaim("authorities", details.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())
                .withIssuedAt(new Date())//设置生效起始时间,现在生效
                .withExpiresAt(generateExpirationDate())//设置失效时间
                .sign(algorithm);//最后按照指定算法签发令牌
    }

    /**
     * 计算JWT失效时间：当前时间往后3天
     * @return 过期时间
     */
    public Date generateExpirationDate() {
        //失效时间是当前时间（签发令牌的时间）+(常量类中定义的时间)*3
        return new Date(System.currentTimeMillis() + 3 * JwtConstant.JWT_EXPIRATION);
    }

}
```

将认证成功后，需要响应给前端的信息封装成一个vo对象
com.xiaoRed.entity.vo.response.AuthorizeVo
```java
@Data
public class AuthorizeVo {
    String username;
    String role;
    String token;
    Date expire;
}
```

认证成功处理器：将vo对象响应给前端
由于目前还没有用户数据，先自己给定
```java
@Resource
JwtUtil jwtUtil;
//认证成功处理器
private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                     Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        UserDetails details = (UserDetails) authentication.getPrincipal();
        String token = jwtUtil.createJWT(details, 1, "小曼");
        AuthorizeVo authorizeVo = new AuthorizeVo();
        authorizeVo.setUsername("小曼");
        authorizeVo.setRole("");
        authorizeVo.setToken(token);
        authorizeVo.setExpire(jwtUtil.generateExpirationDate());
        response.getWriter().write(RestBean.success(authorizeVo).asJsonString());
    }
```
