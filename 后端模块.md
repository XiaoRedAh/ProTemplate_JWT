# RestBean响应类

需要将RestBean转换为json格式，用到fastjson相关api
```xml
 <!--    FastJSON2框架    -->
<dependency>
  <groupId>com.alibaba.fastjson2</groupId>
  <artifactId>fastjson2</artifactId>
  <version>2.0.25</version>
</dependency>
```

com.xiaoRed.entity.RestBean
```java
/**
 * 响应实体类封装，Rest风格
 * @param code 状态码
 * @param data 响应数据
 * @param message 其他消息
 * @param <T> 响应数据类型
 */
public record RestBean<T>(int code, T data, String message) {

    //成功响应，携带数据返回
    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200, data, "请求成功");
    }

    //成功响应，不携带数据返回
    public static <T> RestBean<T> success(){
        return new RestBean<>(200, null, "请求成功");
    }

    //响应失败，需要返回错误码和错误信息
    public static <T> RestBean<T> failure(int code, String message){
        return new RestBean<>(code, null, message);
    }

    //未授权(没有登录),响应失败，固定401错误码，需指定错误信息
    public static <T> RestBean<T> unauthorized(String message){
        return failure(401, message);
    }

    //拒绝访问(登录但没有对应访问权限),响应失败，固定403错误码，需指定错误信息
    public static <T> RestBean<T> forbidden(String message){
        return failure(403, message);
    }

    //将响应对象转换为Json格式
    public String asJsonString(){
        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);
    }

}
```

# SpringSecurity基本配置
>SpringSecurity6.1.2开始，配置的写法和以前相比有所变化
不用继承WebSecurityConfigurerAdapter，而是自行去实现一个返回SecurityFilterChain的方法
`.and()`写法被抛弃，现在要写lambda表达式

com.xiaoRed.config.SecurityConfiguration
把基本的登录，登出配置一下，把csrf，session关掉
```java
/**
 * SpringSecurity相关配置
 */
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       return http
               .authorizeHttpRequests(conf ->conf
                       .requestMatchers("/api/auth/**").permitAll()
                       .anyRequest().authenticated())
               .formLogin(conf -> conf
                       .loginProcessingUrl("/api/auth/login")
                       .successHandler(this::onAuthenticationSuccess)
                       .failureHandler(this::onAuthenticationFailure))
               .logout(conf -> conf
                       .logoutUrl("/api/auth/logout")
                       .logoutSuccessHandler(this::onLogoutSuccess))
               .csrf(AbstractHttpConfigurer::disable)
               //采用JWT方案，不用session了
               .sessionManagement(conf -> conf
                       .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
               .build();
    }

    //认证成功处理器
    private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                         Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.success().asJsonString());
    }

    //认证失败处理器
    private void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                         AuthenticationException exception) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.failure(401, exception.getMessage()).asJsonString());
    }

    //退出登录成功处理器
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,
                                Authentication authentication) throws IOException, ServletException {

    }
}
```

# 数据库校验用户

创建数据库，db_account用户表，并将数据库连接到IDEA
```sql
DROP TABLE IF EXISTS `db_account`;
CREATE TABLE `db_account`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255)  NULL DEFAULT NULL,
  `password` varchar(255)  NULL DEFAULT NULL,
  `email` varchar(255)  NULL DEFAULT NULL,
  `role` varchar(255)  NULL DEFAULT NULL,
  `register_time` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) 
) 
```

导入依赖
```xml
<!--    Mybatis-Plus框架    -->
<dependency>
   <groupId>com.baomidou</groupId>
   <artifactId>mybatis-plus-boot-starter</artifactId>
   <version>3.5.3.1</version>
</dependency>
<!--    MySQL驱动    -->
<dependency>
   <groupId>com.mysql</groupId>
   <artifactId>mysql-connector-j</artifactId>
   <scope>runtime</scope>
</dependency>
```

application.yaml配置数据源
```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/template
    username: root
    password: cronaldo7
```

利用easycode生成db_account数据表的实体类，mapper，service，serviceimpl

com.xiaoRed.entity.dto.Account
```java
/**
 * (Account)表实体类
 *
 * @author makejava
 * @since 2023-08-09 10:12:41
 */
@SuppressWarnings("serial")
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("db_account")
public class Account  {
    @TableId(type = IdType.AUTO)
    private Integer id;

    private String username;
    
    private String password;
    
    private String email;
    
    private String role;
    
    private Date registerTime;
}
```

com.xiaoRed.mapper.AccountMapper
```java
/**
 * (Account)表数据库访问层
 *
 * @author makejava
 * @since 2023-08-09 10:12:40
 */
public interface AccountMapper extends BaseMapper<Account> {

}
```

com.xiaoRed.service.AccountService
注意：由于要实现loadUserByUsername方法，这里还要多继承一个UserDetailsService
```java
/**
 * (Account)表服务接口
 *
 * @author makejava
 * @since 2023-08-09 10:12:43
 */
public interface AccountService extends IService<Account>, UserDetailsService {
    /**
    * 通过用户名/邮箱找到数据库中对应的用户
    */
    public Account findAccountByNameOrEmail(String text);

}
```

com.xiaoRed.service.impl.AccountServiceImpl
在这里实现loadUserByUsername方法，由于要实现通过用户名/邮箱登录，因此这里传进来的username参数实际上有可能是邮箱
这导致最后返回的User的username字段中，存放的可能是Account的username，也可能是email
```java
/**
 * (Account)表服务实现类
 *
 * @author makejava
 * @since 2023-08-09 10:12:45
 */
@Service("accountService")
public class AccountServiceImpl extends ServiceImpl<AccountMapper, Account> implements AccountService {

    /**
     *实现loadUserByUsername方法
     *  1. 从数据库查询用户信息（登录功能）
     *  2. 如果查到，就再去查询对应的权限信息（授权功能）
     *  3. 封装成UserDetails对象返回（这要求再去创建一个UserDetails的实现类）
     *  注意：由于实现通过用户名/邮箱登录，因此这里传进来的username参数实际上有可能是邮箱
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Account account = findAccountByNameOrEmail(username);
        if (account == null)
            throw new UsernameNotFoundException("用户名或密码错误");
        //这个User是SpringSecurity提供的
        /* 这里也可以专门封装一个LoginAccount实体类实现UserDetails，
        User要作为这个实体类的属性成员，在下面返回时返回一个LoginAccount对象*/
        return User
                //实际上，放在这个User的username里的可能是Account的username，也可能是email
                .withUsername(username)
                .password(account.getPassword())
                .roles(account.getRole())
                .build();
    }

    /**
     * 通过用户名/邮箱找到数据库中对应的用户，提供给上面的loadUserByUsername方法
     */
    public Account findAccountByNameOrEmail(String text){
        return this.query()
                .eq("username", text)
                .or()
                .eq("email", text)
                .one();
    }
}
```

com.xiaoRed.config.SecurityConfiguration
数据库存储的是加密后的密码，这里需要把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。
```java
  //创建一个BCryptPasswordEncoder注入容器
    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
```

综上代码，就已经实现了利用数据库校验用户的功能了。
登录成功后，就可以在认证成功处理器中，通过
```java
User details = (User) authentication.getPrincipal();
```
获得查到的用户
接下来，就要搭配JWT去进一步使用


# JWT颁发

导入java-jwt依赖
```xml
<!--    Jwt令牌生成校验框架    -->
<dependency>
  <groupId>com.auth0</groupId>
  <artifactId>java-jwt</artifactId>
  <version>4.3.0</version>
</dependency>
```

JWT常量类
com.xiaoRed.constants.JwtConstant
```java
/**
 * JWT常量类
 */
public class JwtConstant {

    //jwt密钥，随便设，建议长一点
    public static final String JWT_SECRET = "asdadevvefe";

    //jwt失效时间，单位秒。这里一共是24小时
    public static final Long JWT_EXPIRATION = 24 * 60 * 60 * 1000L;
}
```

JWT工具类
com.xiaoRed.utils.JwtUtil
```java
/**
 * Jwt工具类
 */
@Component
public class JwtUtil {

    /**
     * 生成JWT令牌
     * @return 令牌
     */
    public String createJWT(UserDetails details, int id, String username){
        Algorithm algorithm = Algorithm.HMAC256(JwtConstant.JWT_SECRET);//设置加密算法
        return JWT.create()
                .withClaim("id", id)
                .withClaim("name", username)
                .withClaim("authorities", details.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())
                .withIssuedAt(new Date())//设置生效起始时间,现在生效
                .withExpiresAt(generateExpirationDate())//设置失效时间
                .sign(algorithm);//最后按照指定算法签发令牌
    }

    /**
     * 计算JWT失效时间：当前时间往后3天
     * @return 过期时间
     */
    public Date generateExpirationDate() {
        //失效时间是当前时间（签发令牌的时间）+(常量类中定义的时间)*3
        return new Date(System.currentTimeMillis() + 3 * JwtConstant.JWT_EXPIRATION);
    }

}
```

将认证成功后，需要响应给前端的信息封装成一个vo对象
com.xiaoRed.entity.vo.response.AuthorizeVo
```java
@Data
public class AuthorizeVo {
    String username;
    String role;
    String token;
    Date expire;
}
```

认证成功处理器：将用户信息以及一些需要返回的信息封装给authorizeVo对象，响应给前端
```java
@Resource
JwtUtil jwtUtil;
//认证成功处理器
private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                         Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        //从这里拿到loadUserByUsername方法返回的用户信息
        User details = (User) authentication.getPrincipal();
        /*在实现的loadUserByUsername方法中，放在User的username里的可能是Account的username，也可能是email
        因此要想得到Account的username，不能用details.getUsername()，这里有两种方案：
        方案一： 再用findAccountByNameOrEmail方法查一次用户，通过它来获得username【这样的话，登录就要查两次数据库，而且是一样的结果】
        方案二： 采用ThreadLocal
        这里采用方案一
         */
        Account account = accountService.findAccountByNameOrEmail(details.getUsername());
        String token = jwtUtil.createJWT(details, account.getId(), account.getUsername());
        AuthorizeVo authorizeVo = new AuthorizeVo();
        authorizeVo.setUsername(account.getUsername());
        authorizeVo.setRole(account.getRole());
        authorizeVo.setToken(token);
        authorizeVo.setExpire(jwtUtil.generateExpirationDate());
        response.getWriter().write(RestBean.success(authorizeVo).asJsonString());
    }
```

***
测试：登录成功后，向前端响应的结果
```json
{
    "code": 200,
    "data": {
        "expire": "2023-08-12 11:17:06.4",
        "role": "admin",
        "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoieGhyIiwiaWQiOjEsImV4cCI6MTY5MTgxMDIyNiwiaWF0IjoxNjkxNTUxMDI2LCJhdXRob3JpdGllcyI6WyJST0xFX2FkbWluIl19.V8QozFV7rCHVuin3W1hMLlhPmOpU-IUSxjiDm-Q6FvM",
        "username": "xhr"
    },
    "message": "请求成功"
}
```

# 校验请求头携带的JWT

前面已经实现了用户认证登录成功后，将JWT令牌响应给了前端
之后，前端的每次请求，都要在Authorization请求头中携带这个JWT令牌给后端进行校验，格式为：
```
Authorization: Bearer JWT令牌
```

SpringSecurity内部有一个过滤器链，现在需要把自己写的过滤器添加到这个过滤器链中

JWT工具类中添加“从请求头中提取JWT令牌”和“解析JWT”和“toUser”这三个方法
```java
    /**
     * 解析jwt令牌，如果没有问题，则返回令牌；如果有问题(过期，被篡改...)则返回空
     *
     * @return 令牌
     */
    public DecodedJWT resolveJwt(String authorization){
        String token = this.convertToken(authorization);
        if(token == null) return null;
        Algorithm algorithm = Algorithm.HMAC256(JwtConstant.JWT_SECRET);
        JWTVerifier jwtVerifier = JWT.require(algorithm).build();
        try{//如果验证后发现jwt有问题，需要抛异常且返回空
            DecodedJWT decodedJWT = jwtVerifier.verify(token);//对JWT令牌进行验证，看看是否被修改
            Date expireAt = decodedJWT.getExpiresAt();//拿到令牌的失效时间
            return new Date().after(expireAt) ? null : decodedJWT;//如果令牌现在已经失效，返回空；否则返回令牌
        }catch(JWTVerificationException e){//这是运行时异常不会显式地抛出，需要手动捕获
            return null;
        }
    }

    /**
     * 将Authorization请求头中的JWT令牌拿出来
     *
     * @return 令牌
     */
    public String convertToken(String authorization){
        //如果authorization为空或不是以"Bearer "开头，则没有携带JWT令牌，直接返回空
        if(authorization == null || !authorization.startsWith("Bearer "))
            return null;
        return authorization.substring(7);//将前7个字符切割掉，留下JWT令牌
    }

    /**
     * 从解析好的jwt中拿出用户信息
     *
     * @return 令牌
     */
    public UserDetails toUser(DecodedJWT decodedJWT){
        Map<String, Claim> claims = decodedJWT.getClaims();
        return User
                .withUsername(claims.get("name").toString())
                .password("*******")//createJWT方法在生成jwt时没有设置password负载，这里随便写一个
                .authorities(claims.get("authorities").toString())
                .build();
    }
```

自定义JWT认证过滤器
com.xiaoRed.filter.JwtAuthorizeFilter
```java
@Component
public class JwtAuthorizeFilter extends OncePerRequestFilter {

    @Resource
    JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String authorization = request.getHeader("Authorization");//拿到Authorization请求头中的内容
        DecodedJWT jwt = jwtUtil.resolveJwt(authorization);
        if(jwt != null){//解析出来的jwt不为空，说明验证通过了
            //把令牌中的用户信息拿出来
            UserDetails user = jwtUtil.toUser(jwt);
            //用户相关信息封装为Authentication
            //使用UsernamePasswordAuthenticationToken作为实体
            UsernamePasswordAuthenticationToken authenticationToken =
                    new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            ​//把配置好的Authentication塞给SecurityContext表示已经完成验证
            SecurityContextHolder.getContext().setAuthentication(authenticationToken);

        }
        //jwt验证没通过，直接放行（因为后面还有一系列过滤器对其进行认证分析）
        filterChain.doFilter(request, response);
    }
}
```

把JWT认证过滤器添加在UsernamePasswordAuthenticationFilter之前
```java

```

添加异常处理
```java

```