# RestBean响应类

需要将RestBean转换为json格式，用到fastjson相关api
```xml
 <!--    FastJSON2框架    -->
<dependency>
  <groupId>com.alibaba.fastjson2</groupId>
  <artifactId>fastjson2</artifactId>
  <version>2.0.25</version>
</dependency>
```

com.xiaoRed.entity.RestBean
```java
/**
 * 响应实体类封装，Rest风格
 * @param code 状态码
 * @param data 响应数据
 * @param message 其他消息
 * @param <T> 响应数据类型
 */
public record RestBean<T>(int code, T data, String message) {

    //成功响应，携带数据返回
    public static <T> RestBean<T> success(T data){
        return new RestBean<>(200, data, "请求成功");
    }

    //成功响应，不携带数据返回
    public static <T> RestBean<T> success(){
        return new RestBean<>(200, null, "请求成功");
    }

    //响应失败，需要返回错误码和错误信息
    public static <T> RestBean<T> failure(int code, String message){
        return new RestBean<>(code, null, message);
    }

    //未授权(没有登录),响应失败，固定401错误码，需指定错误信息
    public static <T> RestBean<T> unauthorized(String message){
        return failure(401, message);
    }

    //拒绝访问(登录但没有对应访问权限),响应失败，固定403错误码，需指定错误信息
    public static <T> RestBean<T> forbidden(String message){
        return failure(403, message);
    }

    //将响应对象转换为Json格式
    public String asJsonString(){
        return JSONObject.toJSONString(this, JSONWriter.Feature.WriteNulls);
    }

}
```

# SpringSecurity基本配置
>SpringSecurity6.1.2开始，配置的写法和以前相比有所变化
不用继承WebSecurityConfigurerAdapter，而是自行去实现一个返回SecurityFilterChain的方法
`.and()`写法被抛弃，现在要写lambda表达式

com.xiaoRed.config.SecurityConfiguration
把基本的登录，登出配置一下，把csrf，session关掉
```java
/**
 * SpringSecurity相关配置
 */
@Configuration
public class SecurityConfiguration {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
       return http
               .authorizeHttpRequests(conf ->conf
                       .requestMatchers("/api/auth/**").permitAll()
                       .anyRequest().authenticated())
               .formLogin(conf -> conf
                       .loginProcessingUrl("/api/auth/login")
                       .successHandler(this::onAuthenticationSuccess)
                       .failureHandler(this::onAuthenticationFailure))
               .logout(conf -> conf
                       .logoutUrl("/api/auth/logout")
                       .logoutSuccessHandler(this::onLogoutSuccess))
               .csrf(AbstractHttpConfigurer::disable)
               //采用JWT方案，不用session了
               .sessionManagement(conf -> conf
                       .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
               .build();
    }

    //认证成功处理器
    private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                         Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.success().asJsonString());
    }

    //认证失败处理器
    private void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
                                         AuthenticationException exception) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.failure(401, exception.getMessage()).asJsonString());
    }

    //退出登录成功处理器
    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,
                                Authentication authentication) throws IOException, ServletException {

    }
}
```

# 数据库校验用户

创建数据库，db_account用户表，并将数据库连接到IDEA
```sql
DROP TABLE IF EXISTS `db_account`;
CREATE TABLE `db_account`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255)  NULL DEFAULT NULL,
  `password` varchar(255)  NULL DEFAULT NULL,
  `email` varchar(255)  NULL DEFAULT NULL,
  `role` varchar(255)  NULL DEFAULT NULL,
  `register_time` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) 
) 
```

导入依赖
```xml
<!--    Mybatis-Plus框架    -->
<dependency>
   <groupId>com.baomidou</groupId>
   <artifactId>mybatis-plus-boot-starter</artifactId>
   <version>3.5.3.1</version>
</dependency>
<!--    MySQL驱动    -->
<dependency>
   <groupId>com.mysql</groupId>
   <artifactId>mysql-connector-j</artifactId>
   <scope>runtime</scope>
</dependency>
```

application.yaml配置数据源
```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/template
    username: root
    password: cronaldo7
```

利用easycode生成db_account数据表的实体类，mapper，service，serviceimpl

com.xiaoRed.entity.dto.Account
```java
/**
 * (Account)表实体类
 *
 * @author makejava
 * @since 2023-08-09 10:12:41
 */
@SuppressWarnings("serial")
@Data
@AllArgsConstructor
@NoArgsConstructor
@TableName("db_account")
public class Account  {
    @TableId(type = IdType.AUTO)
    private Integer id;

    private String username;
    
    private String password;
    
    private String email;
    
    private String role;
    
    private Date registerTime;
}
```

com.xiaoRed.mapper.AccountMapper
```java
/**
 * (Account)表数据库访问层
 *
 * @author makejava
 * @since 2023-08-09 10:12:40
 */
public interface AccountMapper extends BaseMapper<Account> {

}
```

com.xiaoRed.service.AccountService
注意：由于要实现loadUserByUsername方法，这里还要多继承一个UserDetailsService
```java
/**
 * (Account)表服务接口
 *
 * @author makejava
 * @since 2023-08-09 10:12:43
 */
public interface AccountService extends IService<Account>, UserDetailsService {
    /**
    * 通过用户名/邮箱找到数据库中对应的用户
    */
    public Account findAccountByNameOrEmail(String text);

}
```

com.xiaoRed.service.impl.AccountServiceImpl
在这里实现loadUserByUsername方法，由于要实现通过用户名/邮箱登录，因此这里传进来的username参数实际上有可能是邮箱
这导致最后返回的User的username字段中，存放的可能是Account的username，也可能是email
```java
/**
 * (Account)表服务实现类
 *
 * @author makejava
 * @since 2023-08-09 10:12:45
 */
@Service("accountService")
public class AccountServiceImpl extends ServiceImpl<AccountMapper, Account> implements AccountService {

    /**
     *实现loadUserByUsername方法
     *  1. 从数据库查询用户信息（登录功能）
     *  2. 如果查到，就再去查询对应的权限信息（授权功能）
     *  3. 封装成UserDetails对象返回（这要求再去创建一个UserDetails的实现类）
     *  注意：由于实现通过用户名/邮箱登录，因此这里传进来的username参数实际上有可能是邮箱
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Account account = findAccountByNameOrEmail(username);
        if (account == null)
            throw new UsernameNotFoundException("用户名或密码错误");
        //这个User是SpringSecurity提供的
        /* 这里也可以专门封装一个LoginAccount实体类实现UserDetails，
        User要作为这个实体类的属性成员，在下面返回时返回一个LoginAccount对象*/
        return User
                //实际上，放在这个User的username里的可能是Account的username，也可能是email
                .withUsername(username)
                .password(account.getPassword())
                .roles(account.getRole())
                .build();
    }

    /**
     * 通过用户名/邮箱找到数据库中对应的用户，提供给上面的loadUserByUsername方法
     */
    public Account findAccountByNameOrEmail(String text){
        return this.query()
                .eq("username", text)
                .or()
                .eq("email", text)
                .one();
    }
}
```

com.xiaoRed.config.WebConfiguration
数据库存储的是加密后的密码，这里需要把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。
>由于SecurityConfiguration需要注入AccountService，而这个service在将来的注册功能时，也要使用加密器对密码加密存储，因此也会在自己那里注入加密器。
如果加密器在SecurityConfiguration中注入，未来会发生循环依赖。
因此另外开一个配置类，将加密器注入容器

```java
@Configuration
public class WebConfiguration {
    //创建一个BCryptPasswordEncoder注入容器
    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }
}
```

综上代码，就已经实现了利用数据库校验用户的功能了。
登录成功后，就可以在认证成功处理器中，通过
```java
User details = (User) authentication.getPrincipal();
```
获得查到的用户
接下来，就要搭配JWT去进一步使用


# JWT颁发

导入java-jwt依赖
```xml
<!--    Jwt令牌生成校验框架    -->
<dependency>
  <groupId>com.auth0</groupId>
  <artifactId>java-jwt</artifactId>
  <version>4.3.0</version>
</dependency>
```

JWT常量类
com.xiaoRed.constants.JwtConstant
```java
/**
 * JWT常量类
 */
public class JwtConstant {

    //jwt密钥，随便设，建议长一点
    public static final String JWT_SECRET = "asdadevvefe";

    //jwt失效时间，单位秒。这里一共是24小时
    public static final Long JWT_EXPIRATION = 24 * 60 * 60 * 1000L;
}
```

JWT工具类
com.xiaoRed.utils.JwtUtil
```java
/**
 * Jwt工具类
 */
@Component
public class JwtUtil {

    /**
     * 根据UserDetails生成对应的Jwt令牌
     * @return 令牌
     */
    public String createJWT(UserDetails details, int id, String username){
        Algorithm algorithm = Algorithm.HMAC256(JwtConstant.JWT_SECRET);//设置加密算法
        return JWT.create()
                //给jwt设置一个随机的uuid，用于唯一标识，在黑名单中有用
                .withJWTId(UUID.randomUUID().toString())
                .withClaim("id", id)
                .withClaim("name", username)
                .withClaim("authorities", details.getAuthorities().stream().map(GrantedAuthority::getAuthority).toList())
                .withIssuedAt(new Date())//设置生效起始时间,现在生效
                .withExpiresAt(generateExpirationDate())//设置失效时间
                .sign(algorithm);//最后按照指定算法签发令牌
    }

    /**
     * 计算JWT失效时间：当前时间往后3天
     * @return 过期时间
     */
    public Date generateExpirationDate() {
        //失效时间是当前时间（签发令牌的时间）+(常量类中定义的时间)*3
        return new Date(System.currentTimeMillis() + 3 * JwtConstant.JWT_EXPIRATION);
    }
}
```

将认证成功后，需要响应给前端的信息封装成一个vo对象
com.xiaoRed.entity.vo.response.AuthorizeVo
```java
@Data
public class AuthorizeVo {
    String username;
    String role;
    String token;
    Date expire;
}
```

认证成功处理器：将用户信息以及一些需要返回的信息封装给authorizeVo对象，响应给前端
```java
@Resource
JwtUtil jwtUtil;
//认证成功处理器
private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                         Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        //从这里拿到loadUserByUsername方法返回的用户信息
        User details = (User) authentication.getPrincipal();
        /*在实现的loadUserByUsername方法中，放在User的username里的可能是Account的username，也可能是email
        因此要想得到Account的username，不能用details.getUsername()，这里有两种方案：
        方案一： 再用findAccountByNameOrEmail方法查一次用户，通过它来获得username【这样的话，登录就要查两次数据库，而且是一样的结果】
        方案二： 采用ThreadLocal
        这里采用方案一
         */
        Account account = accountService.findAccountByNameOrEmail(details.getUsername());
        String token = jwtUtil.createJWT(details, account.getId(), account.getUsername());
        AuthorizeVo authorizeVo = new AuthorizeVo();
        authorizeVo.setUsername(account.getUsername());
        authorizeVo.setRole(account.getRole());
        authorizeVo.setToken(token);
        authorizeVo.setExpire(jwtUtil.generateExpirationDate());
        response.getWriter().write(RestBean.success(authorizeVo).asJsonString());
    }
```

***
测试：登录成功后，向前端响应的结果
```json
{
    "code": 200,
    "data": {
        "expire": "2023-08-12 11:17:06.4",
        "role": "admin",
        "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoieGhyIiwiaWQiOjEsImV4cCI6MTY5MTgxMDIyNiwiaWF0IjoxNjkxNTUxMDI2LCJhdXRob3JpdGllcyI6WyJST0xFX2FkbWluIl19.V8QozFV7rCHVuin3W1hMLlhPmOpU-IUSxjiDm-Q6FvM",
        "username": "xhr"
    },
    "message": "请求成功"
}
```

# 校验请求头携带的JWT

前面已经实现了用户认证登录成功后，将JWT令牌响应给了前端
之后，前端的每次请求，都要在Authorization请求头中携带这个JWT令牌给后端进行校验，格式为：
```
Authorization: Bearer JWT令牌
```

JWT工具类中添加“从请求头中提取JWT令牌”和“解析JWT”和“toUser”这三个方法
```java
    /**
     * 解析jwt令牌，如果没有问题，则返回令牌；如果有问题(过期，被篡改，被拉黑...)则返回空
     * @param authorization Authorization请求头中携带的内容
     * @return DecodedJWT
     */
    public DecodedJWT resolveJwt(String authorization){
        String token = this.convertToken(authorization);
        if(token == null) return null;
        Algorithm algorithm = Algorithm.HMAC256(JwtConstant.JWT_SECRET);
        JWTVerifier jwtVerifier = JWT.require(algorithm).build();
        try{//如果验证后发现jwt有问题，需要抛异常且返回空
            DecodedJWT decodedJWT = jwtVerifier.verify(token);//对JWT令牌进行验证，看看是否被修改
            Date expireAt = decodedJWT.getExpiresAt();//拿到令牌的失效时间
            return new Date().after(expireAt) ? null : decodedJWT;//如果令牌现在已经失效，返回空；否则返回令牌
        }catch(JWTVerificationException e){//这是运行时异常不会显式地抛出，需要手动捕获
            return null;
        }
    }

    /**
     * 将Authorization请求头中的JWT令牌拿出来
     * @param authorization Authorization请求头中携带的内容
     * @return 令牌
     */
    public String convertToken(String authorization){
        //如果authorization为空或不是以"Bearer "开头，则没有携带JWT令牌，直接返回空
        if(authorization == null || !authorization.startsWith("Bearer "))
            return null;
        return authorization.substring(7);//将前7个字符切割掉，留下JWT令牌

    }

    /**
     * 从解析好的jwt中拿出用户信息，封装为UserDetails
     * @param decodedJWT 已解析的Jwt对象
     * @return UserDetails
     */
    public UserDetails toUser(DecodedJWT decodedJWT){
        Map<String, Claim> claims = decodedJWT.getClaims();
        return User
                .withUsername(claims.get("name").toString())
                .password("*******")//createJWT方法在生成jwt时没有设置password负载，这里随便写一个
                .authorities(claims.get("authorities").toString())
                .build();
    }
```

自定义JWT认证过滤器
com.xiaoRed.filter.JwtAuthorizeFilter
```java
@Component
public class JwtAuthorizeFilter extends OncePerRequestFilter {

    @Resource
    JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String authorization = request.getHeader("Authorization");//拿到Authorization请求头中的内容
        DecodedJWT jwt = jwtUtil.resolveJwt(authorization);
        if(jwt != null){//解析出来的jwt不为空，说明验证通过了
            //把令牌中的用户信息拿出来
            UserDetails user = jwtUtil.toUser(jwt);
            //用户相关信息封装为Authentication
            //使用UsernamePasswordAuthenticationToken作为实体
            UsernamePasswordAuthenticationToken authenticationToken =
                    new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
            authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            ​//把配置好的Authentication塞给SecurityContext表示已经完成验证
            SecurityContextHolder.getContext().setAuthentication(authenticationToken);

        }
        //jwt验证没通过，直接放行（因为后面还有一系列过滤器对其进行认证分析）
        filterChain.doFilter(request, response);
    }
}
```

把JWT认证过滤器添加在UsernamePasswordAuthenticationFilter之前
com.xiaoRed.config.SecurityConfiguration.java
```java
@Resource
JwtAuthorizeFilter jwtAuthorizeFilter;

@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
  ....
//把JWT校验过滤器添加在UsernamePasswordAuthenticationFilter之前
               .addFilterBefore(jwtAuthorizeFilter, UsernamePasswordAuthenticationFilter.class)
               .build();
```

添加异常处理
com.xiaoRed.config.SecurityConfiguration.java
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
  ....
//配置异常处理
               .exceptionHandling(conf -> conf
                       //JWT校验不通过时触发
                       .authenticationEntryPoint(this::onUnAuthorized)
                       //JWT校验通过，但访问某资源没有对应权限时触发
                       .accessDeniedHandler(this::onAccessDeny) )
...
}

//JWT校验不通过时触发
public void onUnAuthorized(HttpServletRequest request, HttpServletResponse response,
                               AuthenticationException authException) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.unauthorized(authException.getMessage()).asJsonString());
}

//JWT校验通过，但访问某资源没有对应权限时触发
private void onAccessDeny(HttpServletRequest request, HttpServletResponse response,
                              AccessDeniedException e) throws IOException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        response.getWriter().write(RestBean.forbidden(e.getMessage()).asJsonString());
}
```

# JWT退出登录

采用JWT方案的退出登录，不能简单地让客户端删除自己的JWT令牌，因为用户可以自行保存token，这样一来，虽然客户端没有token了，但用户还是可以拿这个token来用

这里采用黑名单方案，退出登录时，将该token存入redis中，在reids中的token都是不可用的，相当于在黑名单中
>隐患：如果有人疯狂请求退出登录接口，redis会爆掉，之后会优化

导入redis依赖
```xml
<!--    Redis交互模块    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

JWT常量类添加：黑名单的key
```java
//存放在redis中的黑名单的key
public static final String JWT_BLACK_LIST = "jwt:blacklist:";
```

JWT工具类添加“判断JWT是否无效”和“手动失效JWT令牌”和“拉黑JWT令牌”这三个方法
```java
    @Resource
    StringRedisTemplate template;

    /**
     * 判断jwt令牌是否无效（是否被列入Redis黑名单）：如果jwt在黑名单中，则无效（用uuid在redis里查）
     * @param uuid 令牌ID
     * @return true表示jwt令牌无效，false表示jwt令牌有效
     */
   public boolean isInValidateJwt(String uuid){
       return Boolean.TRUE.equals(template.hasKey(JwtConstant.JWT_BLACK_LIST + uuid));
   }

    /**
     * 手动失效jwt令牌
     * @param authorization Authorization请求头中携带的内容
     * @return 是否设置成功
     */
    public boolean inValidateJwt(String authorization) {
        String token = this.convertToken(authorization);
        if(token == null) return false;
        Algorithm algorithm = Algorithm.HMAC256(JwtConstant.JWT_SECRET);
        JWTVerifier jwtVerifier = JWT.require(algorithm).build();
        try{//如果验证后发现jwt有问题，需要抛异常且返回空
            DecodedJWT decodedJWT = jwtVerifier.verify(token);//对JWT令牌进行验证，看看是否被修改
            String id = decodedJWT.getId();
            return deleteToken(id, decodedJWT.getExpiresAt());
        }catch(JWTVerificationException e){//这是运行时异常不会显式地抛出，需要手动捕获
            return false;
        }
    }

    /**
     * 将Token列入Redis黑名单中
     * @param uuid 令牌ID
     * @param time 过期时间
     * @return 删除成功返回true，反之返回false
     */
    public boolean deleteToken(String uuid, Date time){
        if(this.isInValidateJwt(uuid))return false;
        Date now = new Date();
        //计算剩余有效时间还有多少，有可能已过期，直接减会得到负数，可以用max函数指定小于0就默认为0
        long expire = Math.max(time.getTime() - now.getTime(), 0);
        //将token存入黑名单
        //key就是黑名单前缀+uuid；value没啥好存的，给个空字符串；设置在redis的过期时间，单位是毫秒
        template.opsForValue().set(JwtConstant.JWT_BLACK_LIST + uuid, "", expire, TimeUnit.MILLISECONDS);
        return true;
    }
```

JWT工具类的resolveJwt方法拿到DecodedJWT后加一个判断：
```java
if (this.isInValidateJwt(decodedJWT.getId()))return null;//还要再判断一下令牌是否有效
```

完善退出登录成功处理器
```java
//退出登录成功处理器
public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response,
                                Authentication authentication) throws IOException, ServletException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");
        String authorization = request.getHeader("Authorization");
        //如果将token拉入黑名单成功，则退出登录成功
        if(jwtUtil.inValidateJwt(authorization))response.getWriter().write(RestBean.success().asJsonString());
        else response.getWriter().write(RestBean.failure(400, "退出登录失败").asJsonString());
    }
```

***
测试
退出登录时携带不正确的token，退出登录会失败

```json
{
    "code": 400,
    "data": null,
    "message": "退出登录失败"
}
```
退出登录时携带正确的token，退出登录成功
```json
{
    "code": 200,
    "data": null,
    "message": "请求成功"
}
```
再拿这个token去访问资源时，就会报错
```json
{
    "code": 401,
    "data": null,
    "message": "Full authentication is required to access this resource"
}
```

# 对象转换工具

在很多场景下，拿到了dto对象后并不能直接将它响应给前端，而是要先转换成vo对象，将vo对象返回给前端

比如之前写的登录成功处理器：
```java
//登录成功处理器
private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                         Authentication authentication) throws IOException, ServletException {
        ...
        Account account = accountService.findAccountByNameOrEmail(details.getUsername());
        String token = jwtUtil.createJWT(details, account.getId(), account.getUsername());
        AuthorizeVo authorizeVo = new AuthorizeVo();
        authorizeVo.setUsername(account.getUsername());
        authorizeVo.setRole(account.getRole());
        authorizeVo.setToken(token);
        authorizeVo.setExpire(jwtUtil.generateExpirationDate());
        response.getWriter().write(RestBean.success(authorizeVo).asJsonString());
}
```

发现在转换过程中，需要对vo对象的每个属性进行set方法，如果和dto对象中的属性同名，还要调用dto对象的get方法
这个代码比较冗长，也不够优雅。而且如果vo中属性很多，一个一个去set，代码量大，也比较麻烦。

这里使用一个对象转换工具，利用反射机制快速地将dto对象转换为vo对象
com.xiaoRed.entity.BaseData
```java
/**
 * 用于DTO快速转换VO实现，只需将DTO类继承此类即可使用
 */
public interface BaseData {
    /**
     * 创建指定的VO类并将当前DTO对象中的所有成员变量值直接复制到VO对象中，vo中额外的成员属性可以用通过consumer用Lambda表达式处理
     * @param clazz 指定VO类型
     * @param consumer 返回VO对象之前可以使用Lambda进行额外处理
     * @return 指定VO对象
     * @param <V> 指定VO类型
     */
    default <V> V asViewObject(Class<V> clazz, Consumer<V> consumer) {
        V v = this.asViewObject(clazz);
        consumer.accept(v);
        return v;
    }

    /**
     * 创建指定的VO类并将当前DTO对象中的所有成员变量值直接复制到VO对象中
     * @param clazz 指定VO类型
     * @return 指定VO对象
     * @param <V> 指定VO类型
     */
    default <V> V asViewObject(Class<V> clazz) {
        try {
            Field[] fields = clazz.getDeclaredFields();
            Constructor<V> constructor = clazz.getConstructor();
            V v = constructor.newInstance();
            Arrays.asList(fields).forEach(field -> convert(field, v));
            return v;
        } catch (ReflectiveOperationException exception) {
            Logger logger = LoggerFactory.getLogger(BaseData.class);
            logger.error("在VO与DTO转换时出现了一些错误", exception);
            throw new RuntimeException(exception.getMessage());
        }
    }

    /**
     * 内部使用，快速将当前类中目标对象字段同名字段的值复制到目标对象字段上
     * @param field 目标对象字段
     * @param target 目标对象
     */
    private void convert(Field field, Object target){
        try {
            Field source = this.getClass().getDeclaredField(field.getName());
            field.setAccessible(true);
            source.setAccessible(true);
            field.set(target, source.get(this));
        } catch (IllegalAccessException | NoSuchFieldException ignored) {}
    }
}
```

***
现在，只需让Account实现`BaseData`接口，就可以获得dto对象快速转换为vo对象的能力了
```java
public class Account implements BaseData
```

登录成功处理器可以优化成这样：
```java
//登录成功处理器
private void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                         Authentication authentication) throws IOException, ServletException {
        ...
        Account account = accountService.findAccountByNameOrEmail(details.getUsername());
        String token = jwtUtil.createJWT(details, account.getId(), account.getUsername());
        //使用对象转换工具的方法快速将Account对象转换为AuthorizeVo对象
        AuthorizeVo authorizeVo = account.asViewObject(AuthorizeVo.class, v -> {
            v.setExpire(jwtUtil.generateExpirationDate());
            v.setToken(token);
        });
        response.getWriter().write(RestBean.success(authorizeVo).asJsonString());
}
```

# 校验请求参数

用户发送请求携带的参数并不总是我们期望的，会出现不合法的参数，而且可能有人故意携带这样的参数来进行攻击，因此需要在请求到来之前，对请求参数做校验

导入依赖
```xml
<!--    接口参数校验模块    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

编写对应的异常处理Controller，自行处理校验不通过时抛出的异常
com.xiaoRed.controller.exception.ValidationController
```java
/**
 * 用于接口参数校验处理的控制器
 */
@Slf4j
@RestControllerAdvice
public class ValidationController {

    /**
     * 与SpringBoot保持一致，校验不通过打印警告信息，而不是直接抛出异常
     * @param exception 验证异常
     * @return 校验结果
     */
    @ExceptionHandler(ValidationException.class)
    public RestBean<Void> validateException(ValidationException exception){
        //仿照springmvc风格打印错误日志
        log.warn("Resolve: [{} : {}]", exception.getClass().getName(), exception.getMessage());
        //错误提示不要太详细，这样如果有人恶意来搞，也不容易知道内部具体细节
        return RestBean.failure(400, "请求参数有误");
    }
}
```

这样，基本的请求参数校验就配置好了，只需要在后续业务编写中，对需要校验的参数添加合适的校验注解，即可实现参数校验

# 发送验证码

## 需求
>能通过用户提交的邮箱地址，向该邮箱发送验证码
根据验证码使用场景的不同(注册，重置密码)，发送的邮件内容也不同
校验请求参数，不合理的参数会提示错误
采用RabbitMQ消息队列实现短信积压发送任务，再由监听器统一处理
采用Redis存储验证码，带过期时间控制
采用Redis进行IP地址限流处理，防刷接口


## 前置工作

导入mail，rabbitmq依赖
```xml
<!--    邮件发送模块    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
<!--    消息队列模块    -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```


application.yaml
配置邮箱，rabbitmq
```yaml
spring:
  mail:
    # 163邮箱的地址为smtp.163.com
    host: smtp.163.com
    # 我的163邮箱账号
    username: m19925651773@163.com
    # 注意密钥是在开启smtp/pop3时自动生成的，记得保存一下，不然就找不到了
    password: ZTREXUEQVBAJLDCW
    port: 465
    properties:
      from: m19925651773@163.com
      mail:
        smtp:
          socketFactory:
            class: javax.net.ssl.SSLSocketFactory
  rabbitmq:
    addresses: localhost
    username: admin
    password: admin
    virtual-host: / # 这个用户有什么权限，就指定什么vh
```

com.xiaoRed.constants.EmailConstant
```java
/**
 * 邮箱相关的常量字符串整合
 */
public class EmailConstant {

    public static final String VERIFY_EMAIL_DATA = "verify:email:data:";
    public static final String VERIFY_EMAIL_LIMIT = "verify:email:limit:";
}
```

## 核心代码

com.xiaoRed.controller.AuthorizeController
```java
/**
 * 用于验证相关的Controller，包含用户的注册、重置密码等操作
 */
@RestController
@RequestMapping("/api/auth")
@Validated
public class AuthorizeController {

    @Resource
    AccountService accountService;

    /**
     * 请求邮件验证码
     * @param type 类型， 必须是register或reset中的一个
     * @param email 请求邮件，必须是合法的邮箱地址才能通过校验
     * @param request 请求，用来获得请求的ip地址
     * @return 是否请求成功
     */
    @GetMapping("/ask-code")
    public RestBean<Void> askVerifyCode(@RequestParam @Pattern(regexp = "(register|reset)") String type, 
    @RequestParam @Email String email, HttpServletRequest request){
        String message = accountService.sendEmailVerifyCode(type, email, request.getRemoteAddr());
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
}
```

限流工具类
package com.xiaoRed.utils.FlowUtil;
```java
/**
 * 限流通用工具
 * 针对于不同的情况进行限流操作，支持限流升级
 */
@Component
public class FlowUtil {

    @Resource
    StringRedisTemplate stringRedisTemplate;

    /**
     * 针对于单次频率限制，请求成功后，在冷却时间内不得再次进行请求，如3秒内不能再次发起请求
     * @param key 位于redis冷却名单中的key ，即verify:email:limit:
     * @param blockTime 冷却时间
     * @return 是否通过限流检查，false表示已经被限流，true表示尚未被限流
     */
    public boolean limitOnceCheck(String key, int blockTime){
        if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(key))){
            return false;
        }else{
            //尚未被限流的，这次请求后就要被加入到限流名单中
            stringRedisTemplate.opsForValue().set(key, "", blockTime, TimeUnit.SECONDS);
            return true;
        }
    }
}
```

RabbitMQ配置类
com.xiaoRed.config.RabbitMqConfiguration
```java
/**
 * RabbitMQ消息队列配置类
 */
@Configuration
public class RabbitMQConfiguration {

    //注册一个Bean名称为emailQueue，名称为mail，采用持久化存储的消息队列
    @Bean("emailQueue")
    public Queue emailQueue(){
        return QueueBuilder
                .durable("mail")
                .build();
    }
}
```

com.xiaoRed.service.AccountService
添加sendEmailVerifyCode方法
```java
String sendEmailVerifyCode(String type, String email, String ip);
```

com.xiaoRed.service.impl.AccountServiceImpl
实现sendEmailVerifyCode方法
```java
    @Resource
    AmqpTemplate amqpTemplate;

    @Resource
    StringRedisTemplate stringRedisTemplate;

    @Resource
    FlowUtil flowUtil;

    /**
     * 发送邮箱验证码
     * @param type 判断在哪个场景下发送验证码：注册邮箱，重置密码，...
     * @param email 将验证码发送给哪个邮箱
     * @param ip 不能一直请求，需要记录ip地址限制请求频率
     * @return 返回null表示发送成功
     */
    @Override
    public String sendEmailVerifyCode(String type, String email, String ip) {
        //加一把锁，防止同一时间被多次调用，保证同一个IP发送的请求需要排队
        synchronized (ip.intern()){
            if(!this.verifyLimit(ip))//verifyLimit方法返回false，说明该ip已经被限流了
                return "请求频繁，请稍后再试";
            //生成6位验证码
            Random random =new Random();
            int code = random.nextInt(899999) + 100000;//这样保证生成的code一定是6位数
            //将"类型，收件人，验证码"分装在一个map中，作为消息，发送到"mail"消息队列中
            Map<String, Object> data = Map.of("type", type, "email", email, "code", code);
            amqpTemplate.convertAndSend("mail", data);
            //将key前缀:目标邮箱作为key，验证码作为value存入redis，设置3分钟有效
            //后续用户提交填写的验证码，就是和这个redis中的做比较
            stringRedisTemplate.opsForValue()
                    .set(EmailConstant.VERIFY_EMAIL_DATA + email, String.valueOf(code), 3, TimeUnit.MINUTES);
            return null;
        }
    }

    /**
     * 针对IP地址进行邮件验证码获取限流
     * @param ip 请求的ip地址
     * @return 是否通过限流验证验证，false表示该ip在限流名单中，true表示尚未被限流
     */
    private boolean verifyLimit(String ip) {
        String key = EmailConstant.VERIFY_EMAIL_LIMIT + ip;
        return flowUtil.limitOnceCheck(key, 60);//限流的冷却时间设置为1分钟
    }
```

## 监听器发送验证码

专门处理验证码发送的监听器
package com.xiaoRed.listener.MailQueueListener
```java
/**
 * 用于处理邮件发送的消息队列监听器，监听名称为"mail"的消息队列
 */
@Component
@RabbitListener(queues = "mail")
public class MailQueueListener {

    @Resource
    JavaMailSender sender;

    @Value("${spring.mail.username}")
    String username;

    /**
     * 处理邮件发送
     * @param data 就是生产者发来的消息，包含邮件信息：类型，收件人，验证码
     */
    @RabbitHandler
    public void sendMailMessage(Map<String, Object> data){
        String email = (String) data.get("email");
        Integer code = (Integer) data.get("code");
        //不同的type，邮件内容不同
        SimpleMailMessage message = switch (data.get("type").toString()) {
            case "register" ->
                    createMailMessage("欢迎注册我们的网站",
                            "您的邮件注册验证码为: "+code+"，有效时间3分钟，为了保障您的账户安全，请勿向他人泄露验证码信息。",
                            email);
            case "reset" ->
                    createMailMessage("您的密码重置邮件",
                            "您好，您正在执行重置密码操作，验证码: "+code+"，有效时间3分钟，如非本人操作，请无视。",
                            email);
            default -> null;
        };
        if(message == null) return;
        sender.send(message);
    }

    /**
     * 快速封装邮件内容
     * @param title 标题
     * @param content 内容
     * @param email 收件人
     * @return 邮件实体
     */
    private SimpleMailMessage createMailMessage(String title, String content, String email){
        SimpleMailMessage message = new SimpleMailMessage();
        message.setSubject(title);
        message.setText(content);
        message.setTo(email);
        message.setFrom(username);
        return message;
    }
}
```

## 测试

postman上携带token，访问http://localhost:8080/api/auth/ask-code?type=register&email=2976698583@qq.com
得到正确的响应
```json
{
    "code": 200,
    "data": null,
    "message": "请求成功"
}
```

同时，对应的邮箱收到了验证码

一分钟冷却时间内如果继续请求，将报错：
```json
{
    "code": 400,
    "data": null,
    "message": "请求频繁，请稍后再试"
}
```

***
如果携带的type参数不是“register”和“reset”其中一个，或email参数的值是非法邮箱地址，都会被校验出请求参数有误：
```json
{
    "code": 400,
    "data": null,
    "message": "请求参数有误"
}
```

控制台也会按照之前指定的格式，打印出对应的错误日志
```
Resolve: [jakarta.validation.ConstraintViolationException : askVerifyCode.type: 需要匹配正则表达式"(register|reset)"]
Resolve: [jakarta.validation.ConstraintViolationException : askVerifyCode.email: 不是一个合法的电子邮件地址]
```

# 实现注册功能

com.xiaoRed.entity.vo.request.EmailRegisterVo
```java
/**
 * 将用户注册请求携带的信息封装为vo
 */
@Data
public class EmailRegisterVo {

    @Email
    String mail;
    @Length(min = 6, max = 6)
    String code;
    @Pattern(regexp = "^[a-zA-Z0-9\\u4e00-\\u9fa5]+$")//不允许包含特殊字符
    @Length(min = 1, max = 10)
    String username;
    @Length(min = 6, max = 20)
    String password;
}

```

com.xiaoRed.controller.AuthorizeController
```java
    /**
     * 注册功能接口
     * @param vo 前端用axios框架，默认发送json，因此用@RequestBody接收json数据，转换为vo实体类
     * @return
     */
    @PostMapping("/register")
    public RestBean<Void> register(@RequestBody @Validated EmailRegisterVo vo){
        String message = accountService.registerEmailAccount(vo);
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com.xiaoRed.service.AccountService
```java
String registerEmailAccount(EmailRegisterVo emailRegisterVo);
```

com.xiaoRed.service.impl.AccountServiceImpl
```java
    @Resource
    PasswordEncoder encoder;

    /**
     * 注册功能：需要检查验证码是否正确以及邮箱、用户名是否已被注册
     * @param emailRegisterVo 前端注册表单提交的信息封装为vo发过来
     * @return null表示注册成功，否则返回错误信息
     */
    @Override
    public String registerEmailAccount(EmailRegisterVo emailRegisterVo) {
        String username = emailRegisterVo.getUsername();
        String email = emailRegisterVo.getMail();
        String code = stringRedisTemplate.opsForValue().get(EmailConstant.VERIFY_EMAIL_DATA + email);
        if (code == null) return "请先获取验证码";
        if (!code.equals(emailRegisterVo.getCode())) return "验证码错误，请重新输入";
        if (this.existsAccountByEmail(email)) return "此电子邮箱已被其他用户注册，请更换一个新的电子邮箱";
        if (this.existsAccountByUsername(username)) return "此用户名已被其他用户注册，请更换一个新的用户名";
        String password = encoder.encode(emailRegisterVo.getPassword());//密码需要加密后才能存入数据库
        //id已经设置过自动递增，因此传null即可；角色默认就是user
        Account account = new Account(null, username, password, email, "user", new Date());
        if (this.save(account)) {
            //注册成功后，redis中对应的那个验证码就没用了，手动删除
            stringRedisTemplate.delete(EmailConstant.VERIFY_EMAIL_DATA + email);
            return null;
        }else {
            return "内部错误，请联系管理员";
        }
    }

    /**
     * 判断用户名是否已被注册
     * @param username
     * @return true表示已被注册
     */
    private boolean existsAccountByUsername(String username) {
        return this.baseMapper.exists(Wrappers.<Account>query().eq("username", username));
    }

    /**
     * 判断电子邮箱是否已被注册
     * @param email
     * @return true表示已被注册
     */
    private boolean existsAccountByEmail(String email) {
        return this.baseMapper.exists(Wrappers.<Account>query().eq("email", email));
    }
```


***
**测试**

还没获取验证码，就发起请求（以下json数据会被后端封装为EmailRegisterVo接收）
```json
{
    "mail": "2976698583@qq.com",
    "code": "123456",
    "username": "xhr",
    "password": "123456"
}
```

得到错误响应，提示先获取验证码
```json
{
    "code": 400,
    "data": null,
    "message": "请先获取验证码"
}
```

申请到验证码，但输入错误的验证码，得到错误响应，提示验证码错误
```json
{
    "code": 400,
    "data": null,
    "message": "验证码错误，请重新输入"
}
```

输入正确的验证码，但用户名xhr已被注册，所以依然得到错误响应
```json
{
    "code": 400,
    "data": null,
    "message": "此用户名已被其他用户注册，请更换一个新的用户名"
}
```

发一个所有环节都能正确通过的请求
```json
{
    "mail": "2976698583@qq.com",
    "code": "494515",
    "username": "xhr",
    "password": "123456"
}
```

得到正确响应
```json
{
    "code": 200,
    "data": null,
    "message": "请求成功"
}
```

数据库也存储到了这个新用户的信息

# 实现重置密码功能

需求
>重置密码有两个步骤：
1、通过邮箱接收验证码，正确填写验证码才能进入下一步
2、重置密码

方案一
1、用户先带着验证码请求第一步的接口(校验验证码)，如果校验通过，后端用redis存储一下标记，表示通过第一步的验证。
2、用户填写新的密码之后 请求第二步的接口(重置密码)，接口里验证该用户是否通过了第一步校验(在redis里查)，如果通过了，才能重置密码。

方案二
1、用户先带着验证码请求第一步的接口(校验验证码)，然后后端仅对验证码是否正确进行验证
2、用户填写新的密码之后，请求第二步的接口(重置密码)，不仅需要带上密码，还要之前的验证码一起。然后再次验校验验证码，如果通过，才能重置密码

方案一在基于session的前后端分离项目模板中使用过了
在这里就用方案二试试。
***
**实现**

首先是将这两步前端请求携带的数据分别封装为vo对象
com.xiaoRed.entity.vo.request.ConfirmResetVo
```java
/**
 * 重置密码第一步：填写账号绑定的电子邮箱，接收验证码，并填写
 * 将前端请求携带的的邮箱，验证码封装为vo
 */
@Data
@AllArgsConstructor
public class ConfirmResetVo {
    @Email
    String email;
    @Length(min = 6, max = 6)
    String code;
}
```

com.xiaoRed.entity.vo.request.ResetPawVo
```java
/**
 * 重置密码第二步：提交重置的密码
 * 将前端请求携带的新密码以及上一步用到的邮箱，验证码封装为vo
 */
@Data
public class ResetPawVo {
    @Email
    String email;
    @Length(min = 6, max = 6)
    String code;
    @Length(min = 5, max = 20)
    String password;
}
```

然后编写核心代码
com.xiaoRed.controller.AuthorizeController
```java
    /**
     * 重置密码第一步：校验验证码，验证码通过才能进行第二步的重置密码
     * @param vo 将前端请求携带的的邮箱，验证码封装为vo
     * @return
     */
    @PostMapping("/reset-confirm")
    public RestBean<Void> resetConfirm(@RequestBody @Validated ConfirmResetVo vo){
        String message = accountService.resetCodeConfirm(vo);
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }

    /**
     * 重置密码第二步：提交重置的密码，更新数据库。
     * @param vo 将前端请求携带的新密码以及上一步用到的邮箱，验证码封装为vo
     * @return
     */
    @PostMapping("/reset-password")
    public RestBean<Void> resetConfirm(@RequestBody @Validated ResetPawVo vo){
        String message = accountService.resetPassword(vo);
        return message == null ? RestBean.success() : RestBean.failure(400, message);
    }
```

com.xiaoRed.service.AccountService
```java
String resetCodeConfirm(ConfirmResetVo confirmResetVo);
String resetPassword(ResetPawVo resetPawVo);
```

com.xiaoRed.service.impl.AccountServiceImpl
```java
    /**
     * 重置密码第一步：校验验证码，验证码通过才能进行第二步的重置密码
     * @param  confirmResetVo 将前端请求携带的的邮箱，验证码封装为vo
     * @return 返回null表示校验通过，否则返回错误信息
     */
    @Override
    public String resetCodeConfirm(ConfirmResetVo confirmResetVo) {
        String email = confirmResetVo.getEmail();
        String code = stringRedisTemplate.opsForValue().get(EmailConstant.VERIFY_EMAIL_DATA + email);
        if (code == null) return "请先获取验证码";
        if (!code.equals(confirmResetVo.getCode())) return "验证码错误，请重新输入";
        return null;
    }

    /**
     * 重置密码第二步：提交重置的密码，更新数据库。为了防止被人跳过第一步来直接重置，这里依然要对验证码再验证一次
     * @param resetPawVo 将前端请求携带的新密码以及上一步用到的邮箱，验证码封装为vo
     * @return 返回null表示重置成功，否则返回错误信息
     */
    @Override
    public String resetPassword(ResetPawVo resetPawVo) {
        String email = resetPawVo.getEmail();
        //即使第一步校验过验证码了，但还是要对验证码再校验一次
        String verify = this.resetCodeConfirm(new ConfirmResetVo(email, resetPawVo.getCode()));
        if (verify != null) return verify;
        String password = encoder.encode(resetPawVo.getPassword());//密码加密后才能存储到数据库
        boolean update = this.update().eq("email", email).set("password", password).update();
        if (update){
            //更新数据库成功了，表明重置成功，对应的验证码没用了，手动从redis删除
            stringRedisTemplate.delete(EmailConstant.VERIFY_EMAIL_DATA + email);
        }
        return null;
    }
```

***
bug:
用户A登录成功，去重置密码，但填写的是用户B的邮箱，重置密码成功后，是把用户B的密码重置了，用户A的密码没有变化。
也就是说用户A只要有其他用户的邮箱，就可以重置其他用户，比如用户B的密码

# 限流操作

应该先到限流过滤器，然后才到SpringSecurity的过滤器(优先级=-100)

常量
```java
//限流相关的常量
public static final String FLOW_LIMIT_COUNTER = "flow:limit:counter";
public static final String FLOW_LIMIT_BLOCK = "flow:limit:block";

//过滤器优先级
public final static int ORDER_FLOW_LIMIT = -101;
```

com.xiaoRed.filter.FlowLimitingFilter
```java
/**
 * 限流控制过滤器
 * 防止用户高频访问接口，借用redis限流
 */
@Slf4j
@Component
@Order(Const.ORDER_FLOW_LIMIT)
public class FlowLimitingFilter extends HttpFilter {

    @Resource
    StringRedisTemplate stringRedisTemplate;

    @Override
    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
        String ip = request.getRemoteAddr();
        if(!requestCount(ip)){//如果没有通过限流检查，则就拒绝请求，响应错误提示
            this.writeBlockMessage(response);
        }
        //如果通过限流检查，直接放行给下一个过滤器
        else chain.doFilter(request, response);
    }

    /**
     * 尝试对指定IP地址请求计数，如果被限制则无法继续访问
     * @param ip 请求的ip地址
     * @return 返回true表示请求频率正常，无需封禁；返回false表示请求频繁，对ip封禁
     */
    private boolean requestCount(String ip) {
        if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(Const.FLOW_LIMIT_BLOCK + ip)))
            return false;
        else return limitPeriodCheck(ip);
    }

    /**
     * 针对于在时间段内多次请求限制，如3秒内限制请求20次，超出频率则封禁一段时间
     * @param ip 请求的ip地址
     * @return 返回true表示请求频率正常，无需封禁；返回false表示请求频繁，对ip封禁
     */
    private boolean limitPeriodCheck(String ip) {
        if (Boolean.TRUE.equals(stringRedisTemplate.hasKey(Const.FLOW_LIMIT_COUNTER + ip))){//如果该ip已在redis中
            //redis中对应ip的请求计数自增1，然后拿出来（有可能这一瞬间该键值对刚好失效，因此要有判断null的情况，为null返回0）
            long count = Optional.ofNullable(stringRedisTemplate.opsForValue().increment(Const.FLOW_LIMIT_COUNTER + ip)).orElse(0L);
            if (count > 20){//如果请求计数超过20次，则将ip拉入封禁名单，封禁时间30秒
                stringRedisTemplate.opsForValue().set(Const.FLOW_LIMIT_BLOCK + ip, "", 30, TimeUnit.SECONDS);
                return false;
            }
        }else{//如果该ip没有在redis中，说明这三秒内该ip第一次发起请求，因此存入redis计数，初值为1
            stringRedisTemplate.opsForValue().set(Const.FLOW_LIMIT_COUNTER + ip, "1", 3, TimeUnit.SECONDS);
        }
        return true;
    }

    /**
     * 为响应编写拦截内容，提示用户操作频繁
     * @param response
     * @throws IOException
     */
    private void writeBlockMessage(HttpServletResponse response) throws IOException {
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType("application/json;charset = utf-8");
        PrintWriter writer = response.getWriter();
        writer.write(RestBean.forbidden("操作频繁，请稍后再试").asJsonString());
    }
}
```

# 配置跨域

一般来说，配置跨域可以在SpringSecurity中进行配置
但由于之前设计限流操作时，限流过滤器的优先级设置在SpringSecurity过滤器之前，因此请求可能到不了SpringSecurity这里。因此在SpringSecurity中配置跨域是有一定问题的

这里就另外自定义一个跨域过滤器，它的优先级是最高的，请求通过它之后才能到限流过滤器，最后才到SpringSecurity过滤器。

常量
```java
public final static int ORDER_CORS = -102;
```

跨域过滤器
com.xiaoRed.filter.CorsFilter
```java
/**
 * 跨域配置过滤器，仅处理跨域，添加跨域响应头
 */
@Component
//SpringSecurity过滤器的优先级-100，限流过滤器的优先级=-101，跨域处理要在它们之前
@Order(Const.ORDER_CORS)
public class CorsFilter extends HttpFilter {

    @Override
    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
        this.addCorsHeader(request, response);
        chain.doFilter(request, response);
    }

    /**
     * 添加所有跨域相关响应头
     * @param request 请求
     * @param response 响应
     */
    private void addCorsHeader(HttpServletRequest request, HttpServletResponse response) {
        //设置允许哪个地址的请求可以跨域，这里是允许所有请求地址（只要向我们后端发送请求，都允许跨域）
        //也可以将第二个参数指定为唯一的那个前端地址，这样更加安全
        response.addHeader("Access-Control-Allow-Origin", request.getHeader("Origin"));
        //设置哪些请求方法允许跨域
        response.addHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        //设置允许携带的请求头
        response.addHeader("Access-Control-Allow-Headers", "Authorization, Content-Type");
    }
}
```

***
**测试**
配置完成后，前端项目可以正常向后端服务器发送请求了
后端的响应头出现了过滤器配置的那三个响应头:
```
Access-Control-Allow-Headers: Authorization, Content-Type
Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS
Access-Control-Allow-Origin: http://127.0.0.1:5173
```

# 配置Swagger接口文档

导入依赖
```xml
<!--    Swagger文档生成框架    -->
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.1.0</version>
</dependency>
```

Swagger配置类
com.xiaoRed.config.SwaggerConfiguration
```java
/**
 * Swagger开发文档相关配置
 */
@Configuration
@SecurityScheme(type = SecuritySchemeType.HTTP, scheme = "Bearer",
        name = "Authorization", in = SecuritySchemeIn.HEADER)
@OpenAPIDefinition(security = { @SecurityRequirement(name = "Authorization") })
public class SwaggerConfiguration {

    /**
     * 配置API文档的标题，介绍等相关信息
     * @return OpenAPI
     */
    @Bean
    public OpenAPI springDocOpenAPI() {
        return new OpenAPI()
                .info(new Info().title("基于JWT的前后端分离项目模板 API 文档")
                        .description("欢迎来到本项目API测试文档，在这里可以快速进行接口调试")
                        .version("1.0")
                        .license(new License()
                                .name("项目开源地址")
                                .url("https://github.com/XiaoRedAh/ProTemplate_JWT")
                        )
                );
    }

    /**
     * 配置自定义的OpenApi相关信息
     * @return OpenApiCustomizer
     */
    @Bean
    public OpenApiCustomizer customerGlobalHeaderOpenApiCustomizer() {
        return api -> this.authorizePathItems().forEach(api.getPaths()::addPathItem);
    }

    /**
     * 登录接口和退出登录接口手动添加一下
     * @return PathItems
     */
    private Map<String, PathItem> authorizePathItems(){
        Map<String, PathItem> map = new HashMap<>();
        map.put("/api/auth/login", new PathItem()
                .post(new Operation()
                        .tags(List.of("登录校验相关"))
                        .summary("登录验证接口")
                        .addParametersItem(new QueryParameter()
                                .name("username")
                                .required(true)
                        )
                        .addParametersItem(new QueryParameter()
                                .name("password")
                                .required(true)
                        )
                        .responses(new ApiResponses()
                                .addApiResponse("200", new ApiResponse()
                                        .description("OK")
                                        .content(new Content().addMediaType("*/*", new MediaType()
                                                .example(RestBean.success(new AuthorizeVo()).asJsonString())
                                        ))
                                )
                        )
                )
        );
        map.put("/api/auth/logout", new PathItem()
                .get(new Operation()
                        .tags(List.of("登录校验相关"))
                        .summary("退出登录接口")
                        .responses(new ApiResponses()
                                .addApiResponse("200", new ApiResponse()
                                        .description("OK")
                                        .content(new Content().addMediaType("*/*", new MediaType()
                                                .example(RestBean.success())
                                        ))
                                )
                        )
                )

        );
        return map;
    }
}
```

SpringSecurity配置类中，将访问权限开启
```java
.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
```

综上，访问 http://localhost:8080/swagger-ui/index.html 即可在线查看接口文档